/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/web-serial-polyfill@1.0.15/dist/serial.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";export var SerialPolyfillProtocol;!function(t){t[t.UsbCdcAcm=0]="UsbCdcAcm"}(SerialPolyfillProtocol||(SerialPolyfillProtocol={}));const kSetLineCoding=32,kSetControlLineState=34,kSendBreak=35,kDefaultBufferSize=255,kDefaultDataBits=8,kDefaultParity="none",kDefaultStopBits=1,kAcceptableDataBits=[16,8,7,6,5],kAcceptableStopBits=[1,2],kAcceptableParity=["none","even","odd"],kParityIndexMapping=["none","odd","even"],kStopBitsIndexMapping=[1,1.5,2],kDefaultPolyfillOptions={protocol:SerialPolyfillProtocol.UsbCdcAcm,usbControlInterfaceClass:2,usbTransferInterfaceClass:10};function findInterface(t,e){const i=t.configurations[0];for(const t of i.interfaces){if(t.alternates[0].interfaceClass===e)return t}throw new TypeError(`Unable to find interface with class ${e}.`)}function findEndpoint(t,e){const i=t.alternates[0];for(const t of i.endpoints)if(t.direction==e)return t;throw new TypeError(`Interface ${t.interfaceNumber} does not have an ${e} endpoint.`)}class UsbEndpointUnderlyingSource{constructor(t,e,i){this.type="bytes",this.device_=t,this.endpoint_=e,this.onError_=i}pull(t){(async()=>{var e;let i;if(t.desiredSize){const e=t.desiredSize/this.endpoint_.packetSize;i=Math.ceil(e)*this.endpoint_.packetSize}else i=this.endpoint_.packetSize;try{const s=await this.device_.transferIn(this.endpoint_.endpointNumber,i);if("ok"!=s.status&&(t.error(`USB error: ${s.status}`),this.onError_()),null===(e=s.data)||void 0===e?void 0:e.buffer){const e=new Uint8Array(s.data.buffer,s.data.byteOffset,s.data.byteLength);t.enqueue(e)}}catch(e){t.error(e.toString()),this.onError_()}})()}}class UsbEndpointUnderlyingSink{constructor(t,e,i){this.device_=t,this.endpoint_=e,this.onError_=i}async write(t,e){try{const i=await this.device_.transferOut(this.endpoint_.endpointNumber,t);"ok"!=i.status&&(e.error(i.status),this.onError_())}catch(t){e.error(t.toString()),this.onError_()}}}export class SerialPort{constructor(t,e){this.polyfillOptions_=Object.assign(Object.assign({},kDefaultPolyfillOptions),e),this.outputSignals_={dataTerminalReady:!1,requestToSend:!1,break:!1},this.device_=t,this.controlInterface_=findInterface(this.device_,this.polyfillOptions_.usbControlInterfaceClass),this.transferInterface_=findInterface(this.device_,this.polyfillOptions_.usbTransferInterfaceClass),this.inEndpoint_=findEndpoint(this.transferInterface_,"in"),this.outEndpoint_=findEndpoint(this.transferInterface_,"out")}get readable(){var t;return!this.readable_&&this.device_.opened&&(this.readable_=new ReadableStream(new UsbEndpointUnderlyingSource(this.device_,this.inEndpoint_,(()=>{this.readable_=null})),{highWaterMark:null!==(t=this.serialOptions_.bufferSize)&&void 0!==t?t:255})),this.readable_}get writable(){var t;return!this.writable_&&this.device_.opened&&(this.writable_=new WritableStream(new UsbEndpointUnderlyingSink(this.device_,this.outEndpoint_,(()=>{this.writable_=null})),new ByteLengthQueuingStrategy({highWaterMark:null!==(t=this.serialOptions_.bufferSize)&&void 0!==t?t:255}))),this.writable_}async open(t){this.serialOptions_=t,this.validateOptions();try{await this.device_.open(),null===this.device_.configuration&&await this.device_.selectConfiguration(1),await this.device_.claimInterface(this.controlInterface_.interfaceNumber),this.controlInterface_!==this.transferInterface_&&await this.device_.claimInterface(this.transferInterface_.interfaceNumber),await this.setLineCoding(),await this.setSignals({dataTerminalReady:!0})}catch(t){throw this.device_.opened&&await this.device_.close(),new Error("Error setting up device: "+t.toString())}}async close(){const t=[];this.readable_&&t.push(this.readable_.cancel()),this.writable_&&t.push(this.writable_.abort()),await Promise.all(t),this.readable_=null,this.writable_=null,this.device_.opened&&(await this.setSignals({dataTerminalReady:!1,requestToSend:!1}),await this.device_.close())}async forget(){return this.device_.forget()}getInfo(){return{usbVendorId:this.device_.vendorId,usbProductId:this.device_.productId}}reconfigure(t){return this.serialOptions_=Object.assign(Object.assign({},this.serialOptions_),t),this.validateOptions(),this.setLineCoding()}async setSignals(t){if(this.outputSignals_=Object.assign(Object.assign({},this.outputSignals_),t),void 0!==t.dataTerminalReady||void 0!==t.requestToSend){const t=(this.outputSignals_.dataTerminalReady?1:0)|(this.outputSignals_.requestToSend?2:0);await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:34,value:t,index:this.controlInterface_.interfaceNumber})}if(void 0!==t.break){const t=this.outputSignals_.break?65535:0;await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:35,value:t,index:this.controlInterface_.interfaceNumber})}}validateOptions(){if(!this.isValidBaudRate(this.serialOptions_.baudRate))throw new RangeError("invalid Baud Rate "+this.serialOptions_.baudRate);if(!this.isValidDataBits(this.serialOptions_.dataBits))throw new RangeError("invalid dataBits "+this.serialOptions_.dataBits);if(!this.isValidStopBits(this.serialOptions_.stopBits))throw new RangeError("invalid stopBits "+this.serialOptions_.stopBits);if(!this.isValidParity(this.serialOptions_.parity))throw new RangeError("invalid parity "+this.serialOptions_.parity)}isValidBaudRate(t){return t%1==0}isValidDataBits(t){return void 0===t||kAcceptableDataBits.includes(t)}isValidStopBits(t){return void 0===t||kAcceptableStopBits.includes(t)}isValidParity(t){return void 0===t||kAcceptableParity.includes(t)}async setLineCoding(){var t,e,i;const s=new ArrayBuffer(7),n=new DataView(s);n.setUint32(0,this.serialOptions_.baudRate,!0),n.setUint8(4,kStopBitsIndexMapping.indexOf(null!==(t=this.serialOptions_.stopBits)&&void 0!==t?t:1)),n.setUint8(5,kParityIndexMapping.indexOf(null!==(e=this.serialOptions_.parity)&&void 0!==e?e:"none")),n.setUint8(6,null!==(i=this.serialOptions_.dataBits)&&void 0!==i?i:8);if("ok"!=(await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:32,value:0,index:this.controlInterface_.interfaceNumber},s)).status)throw new DOMException("NetworkError","Failed to set line coding.")}}class Serial{async requestPort(t,e){e=Object.assign(Object.assign({},kDefaultPolyfillOptions),e);const i=[];if(t&&t.filters)for(const s of t.filters){const t={classCode:e.usbControlInterfaceClass};void 0!==s.usbVendorId&&(t.vendorId=s.usbVendorId),void 0!==s.usbProductId&&(t.productId=s.usbProductId),i.push(t)}0===i.length&&i.push({classCode:e.usbControlInterfaceClass});const s=await navigator.usb.requestDevice({filters:i});return new SerialPort(s,e)}async getPorts(t){t=Object.assign(Object.assign({},kDefaultPolyfillOptions),t);const e=await navigator.usb.getDevices(),i=[];return e.forEach((e=>{try{const s=new SerialPort(e,t);i.push(s)}catch(t){}})),i}}export const serial=new Serial;
//# sourceMappingURL=/sm/db01ffeed57e472fb01ed2879023506bdfa112c950a8fe055e007cf72bdb37b6.map